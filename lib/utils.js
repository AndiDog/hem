// Generated by CoffeeScript 1.6.3
(function() {
  var clean, extend, flatten, fs, isWin, path, utils,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  path = require('path');

  fs = require('fs');

  utils = {};

  isWin = !!require('os').platform().match(/^win/);

  utils.flatten = flatten = function(array, results) {
    var item, _i, _len;
    if (results == null) {
      results = [];
    }
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (Array.isArray(item)) {
        flatten(item, results);
      } else if (item) {
        results.push(item);
      }
    }
    return results;
  };

  utils.arrayToString = function(value) {
    var line, result, _i, _len;
    if (value == null) {
      value = "";
    }
    if (Array.isArray(value)) {
      result = "";
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        line = value[_i];
        result += line + "\n";
      }
      return result;
    } else {
      return value;
    }
  };

  utils.removeDuplicateValues = function(array) {
    var newArray, value, _i, _len;
    newArray = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      value = array[_i];
      if (__indexOf.call(newArray, value) < 0) {
        newArray.push(value);
      }
    }
    return newArray;
  };

  utils.toArray = function(value) {
    if (value == null) {
      value = [];
    }
    if (Array.isArray(value)) {
      return value;
    } else {
      return [value];
    }
  };

  utils.startsWith = function(str, value) {
    return (str != null ? str.slice(0, value.length) : void 0) === value;
  };

  utils.endsWith = function(str, value) {
    return (str != null ? str.slice(-value.length) : void 0) === value;
  };

  utils.extend = extend = function(a, b) {
    var x;
    for (x in b) {
      if (typeof b[x] === 'object' && !Array.isArray(b[x])) {
        a[x] || (a[x] = {});
        extend(a[x], b[x]);
      } else {
        a[x] = b[x];
      }
    }
    return a;
  };

  utils.loadAsset = function(asset) {
    return require("../assets/" + asset);
  };

  utils.isDirectory = function(dir) {
    var e, stats;
    try {
      stats = fs.lstatSync(dir);
      return stats.isDirectory();
    } catch (_error) {
      e = _error;
      return false;
    }
  };

  clean = function(values, sep, trimStart) {
    var regexp, result, value, _i, _len;
    if (trimStart == null) {
      trimStart = false;
    }
    result = "";
    for (_i = 0, _len = values.length; _i < _len; _i++) {
      value = values[_i];
      if (value) {
        result = result + sep + value;
      }
    }
    regexp = new RegExp("" + sep + "+", "g");
    result = result.replace(regexp, sep);
    if (trimStart && utils.startsWith(result, sep)) {
      result = result.slice(sep.length);
    }
    if (utils.endsWith(result, sep)) {
      result = result.slice(0, -sep.length);
    }
    return result;
  };

  utils.cleanPath = function() {
    var cleanPath, paths, result;
    paths = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    result = clean(paths, path.sep, true);
    if (isWin || true) {
      cleanPath = new RegExp(/\//g);
      result = result.replace(cleanPath, path.sep);
    }
    return result;
  };

  utils.cleanRoute = function() {
    var routes;
    routes = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return clean(routes, "/");
  };

  module.exports = utils;

}).call(this);
