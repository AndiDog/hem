// Generated by CoffeeScript 1.7.0
(function() {
  var detective, from_filename, from_source, fs, lookup_path, natives, node_module_paths, path, resolve, _module;

  _module = require('module');

  natives = process.binding('natives');

  path = require('path');

  fs = require('fs');

  detective = require('detective');

  from_source = function(source, parent, opt, cb) {
    var cache, ignore_missing, next, requires, result;
    cache = opt.cache;
    ignore_missing = true;
    requires = detective(source);
    result = [];
    requires = requires.filter(function(elem, idx) {
      return requires.indexOf(elem) === idx;
    });
    return (next = function() {
      var id, req;
      req = requires.shift();
      if (!req) {
        return cb(null, result);
      }
      id = req;
      return resolve(req, parent, function(err, full_path, ignore) {
        var new_parent;
        if (err) {
          return cb(err);
        }
        if (!full_path) {
          if (natives[id]) {
            result.push({
              id: id,
              core: true
            });
            return next();
          }
          if (ignore_missing) {
            return next();
          }
          return cb(new Error('Cannot find module: \'' + req + '\' ' + 'required from ' + parent.filename));
        }
        if (ignore) {
          result.push({
            id: id,
            filename: full_path
          });
          return next();
        }
        new_parent = {
          id: id,
          filename: full_path,
          paths: parent.paths.concat(node_module_paths(full_path))
        };
        return from_filename(full_path, new_parent, opt, function(err, deps, src) {
          var res;
          if (err) {
            return cb(err);
          }
          res = {
            id: id,
            filename: full_path,
            deps: deps
          };
          if (opt.includeSource) {
            res.source = src;
          }
          result.push(res);
          return next();
        });
      });
    })();
  };

  from_filename = function(filename, parent, opt, cb) {
    var cache, cached;
    cache = opt.cache;
    cached = cache[filename];
    if (cached) {
      return cb(null, cached.deps, cached.src);
    }
    return fs.readFile(filename, 'utf8', function(err, content) {
      var result;
      if (err) {
        return cb(err);
      }
      result = cache[filename] = {
        deps: []
      };
      try {
        return from_source(content, parent, opt, function(err, deps) {
          if (err) {
            return cb(err);
          }
          result.deps = deps;
          if (opt.includeSource) {
            result.src = content;
          }
          return cb(err, deps, content);
        });
      } catch (_error) {
        err = _error;
        err.message = filename + ': ' + err.message;
        throw err;
      }
    });
  };

  resolve = function(id, parent, cb) {
    return cb(null, lookup_path(id, parent));
  };

  lookup_path = function(name, parent) {
    var paths, resolved_module;
    resolved_module = _module.Module._resolveLookupPaths(name, parent);
    paths = resolved_module[1];
    return _module.Module._findPath(name, paths);
  };

  node_module_paths = function(filename) {
    return _module.Module._nodeModulePaths(path.dirname(filename));
  };

  module.exports = function(mod, opt, cb) {
    var entry_parent;
    opt || (opt = {});
    if (typeof opt === 'function') {
      cb = opt;
      opt = {};
    }
    opt.cache || (opt.cache = {});
    entry_parent = {
      id: mod.id,
      filename: mod.filename,
      paths: node_module_paths(mod.filename)
    };
    return from_source(mod.source, entry_parent, opt, cb);
  };

}).call(this);
