// Generated by CoffeeScript 1.7.0
(function() {
  var Log, Patch, Stitch, Utils, baseFromGlob, cache, compilers, createPatchFromPath, depsFromPatch, detective, findAllDependencies, fs, glob, lookup_path, modulerize, natives, node_module_paths, resolve, walk, _module, _path,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _path = require('path');

  fs = require('fs');

  compilers = require('./compilers');

  Utils = require('./utils');

  Log = require('./log');

  glob = require('globule');

  detective = require('detective');

  _module = require('module');

  natives = process.binding('natives');

  cache = {
    file: {},
    byId: {}
  };

  baseFromGlob = function(path) {
    var hmm, part, paths, result, _i, _len;
    path = _path.resolve(path);
    paths = path.split('/');
    result = [];
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      part = paths[_i];
      if (__indexOf.call(part, '*') >= 0) {
        break;
      } else {
        result.push(part);
      }
    }
    return hmm = "" + (result.join('/'));
  };

  walk = function(type, path, parent) {
    var file, files, patch, result, stat, _i, _len;
    result = [];
    files = glob.find(path);
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      stat = fs.statSync(file);
      if (stat.isFile()) {
        patch = createPatchFromPath({
          type: type,
          fullPath: file,
          parent: parent
        });
        if (patch) {
          result.push(patch);
        }
      }
    }
    return result;
  };

  createPatchFromPath = function(options) {
    var fullPath, id, parent, patch, type;
    type = options.type;
    fullPath = options.fullPath;
    parent = options.parent;
    if (!cache.file[fullPath]) {
      id = modulerize(fullPath, parent, _path.extname(fullPath));
      patch = new Patch(id, fullPath, type);
    }
    return cache.file[fullPath];
  };

  modulerize = function(filename, parent, ext) {
    var baseName, dirName, id, modName, parts;
    if (filename[0] === ".") {
      parts = parent.split(_path.sep);
      parent = parent.replace(/(node_modules(\/|\\)[^/\\]+)\/.+/, "$1");
      filename = _path.resolve(parent, filename);
      id = filename.replace(/.+node_modules(\/|\\)/, "");
    } else {
      id = filename.replace(_path.join(parent, _path.sep), '');
    }
    baseName = ext ? _path.basename(id, ext) : _path.basename(id);
    dirName = _path.dirname(id);
    modName = _path.join(_path.dirname(id), baseName);
    return modName.replace(/\\/g, '/');
  };

  findAllDependencies = function(patch, patches, options) {
    var deps, next;
    deps = patch.deps || (patch.deps = depsFromPatch(patch, options));
    return (next = function() {
      var dep, id;
      id = deps.shift();
      if (!id) {
        return;
      }
      dep = cache.byId[id];
      if (__indexOf.call(patches, dep) < 0) {
        patches.push(dep);
        findAllDependencies(dep, patches, options);
      }
      return next();
    })();
  };

  Stitch = (function() {
    Stitch.instances = [];

    Stitch.ignoreMissingDependencies = true;

    Stitch.reportMissingDependencies = false;

    Stitch.resolvers = {
      js: function(patches, options) {
        var identifier, patch, _i, _len;
        if (options == null) {
          options = {};
        }
        options.ignoreMissingDependencies || (options.ignoreMissingDependencies = Stitch.ignoreMissingDependencies);
        options.reportMissingDependencies || (options.reportMissingDependencies = Stitch.reportMissingDependencies);
        if (options.reportMissingDependencies || !options.ignoreMissingDependencies || options.npm) {
          for (_i = 0, _len = patches.length; _i < _len; _i++) {
            patch = patches[_i];
            findAllDependencies(patch, patches, options);
          }
        }
        if (options.bundle) {
          if (options.commonjs) {
            identifier = typeof options.commonjs === 'boolean' ? 'require' : options.commonjs;
            return {
              source: Stitch.bundle(patches, identifier)
            };
          } else {
            return {
              source: Stitch.join(patches, options.separator)
            };
          }
        } else {
          return patches;
        }
      },
      css: function(patches, options) {
        if (options == null) {
          options = {};
        }
        if (options.bundle) {
          return {
            source: Stitch.join(patches, options.separator)
          };
        } else {
          return patches;
        }
      }
    };

    Stitch.bundle = function(patches, identifier) {
      var context;
      context = {
        identifier: identifier,
        modules: patches
      };
      return Utils.tmpl("stitch", context);
    };

    Stitch.join = function(patches, separator) {
      var patch;
      if (separator == null) {
        separator = "\n";
      }
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = patches.length; _i < _len; _i++) {
          patch = patches[_i];
          _results.push(patch.source);
        }
        return _results;
      })()).join(separator);
    };

    Stitch.remove = function(filename) {
      var patch, stitch, _i, _len, _ref, _results;
      patch = cache.file[_path.resolve(filename)];
      if (!patch) {
        return;
      }
      delete cache.file[patch.filename];
      delete cache.byId[patch.id];
      _ref = this.instances;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stitch = _ref[_i];
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = stitch.walk;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            patch = _ref1[_j];
            if (stitch.cache) {
              if (patch.filename === filename) {
                _results1.push(delete stitch.cache);
              } else {
                _results1.push(void 0);
              }
            }
          }
          return _results1;
        })());
      }
      return _results;
    };

    Stitch.register = function(stitch) {
      return this.instances.push(stitch);
    };

    function Stitch(paths, type) {
      var path;
      this.paths = paths != null ? paths : [];
      this.type = type != null ? type : 'js';
      this.paths = (function() {
        var _i, _len, _ref, _results;
        _ref = this.paths;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          _results.push(_path.resolve(path));
        }
        return _results;
      }).call(this);
      if (!Stitch.resolvers[this.type]) {
        throw new Error("Invalid type supplied to Stitch contructor");
      }
      Stitch.register(this);
    }

    Stitch.prototype.resolve = function(options) {
      var parent, path, _i, _len, _ref;
      if (options == null) {
        options = {};
      }
      if (!this.cache) {
        this.walk = [];
        _ref = this.paths;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          parent = baseFromGlob(path);
          this.walk.push.apply(this.walk, walk(this.type, path, parent));
        }
        this.cache = Stitch.resolvers[this.type](this.walk, options);
      }
      return this.cache;
    };

    return Stitch;

  })();

  Patch = (function() {
    function Patch(id, filename, type) {
      var ext;
      this.id = id;
      this.filename = filename;
      this.type = type != null ? type : "js";
      ext = _path.extname(this.filename).slice(1).toLowerCase();
      if (compilers[ext]) {
        this.source || (this.source = compilers[ext](this.filename));
        cache.file[this.filename] = this;
        if (this.id) {
          cache.byId[this.id] = this;
        }
      }
    }

    return Patch;

  })();

  lookup_path = function(name, parent) {
    var paths, resolved_module;
    resolved_module = _module.Module._resolveLookupPaths(name, parent);
    paths = resolved_module[1];
    return _module.Module._findPath(name, paths);
  };

  node_module_paths = function(filename) {
    return _module.Module._nodeModulePaths(_path.dirname(filename));
  };

  resolve = function(id, parent, cb) {
    parent.paths || (parent.paths = node_module_paths(parent.filename));
    return cb(lookup_path(id, parent));
  };

  depsFromPatch = function(patch, options) {
    var next, requires, result;
    result = [];
    requires = detective(patch.source);
    requires = requires.filter(function(elem, idx) {
      return requires.indexOf(elem) === idx;
    });
    return (next = function() {
      var id, req;
      req = requires.shift();
      if (!req) {
        return result;
      }
      id = modulerize(req, patch.filename);
      return resolve(req, patch, function(full_path) {
        var dep, newPatch;
        if (!full_path) {
          if (cache.byId[id]) {
            result.push(id);
            return next();
          }
          if (natives[id] && options.npm) {
            throw new Error('Cannot require native module: \'' + req + '\' from ' + patch.filename);
          }
          if (options.ignoreMissingDependencies === false) {
            throw new Error("" + patch.filename + " contains missing module " + id);
          }
          if (options.reportMissingDependencies) {
            Log.info("<yellow>Warning:</yellow> " + patch.filename + " contains missing module <green>" + id + "</green>");
          }
          return next();
        }
        if (!options.npm) {
          return next();
        }
        dep = cache.file[full_path];
        if (dep) {
          result.push(dep.id);
          return next();
        }
        newPatch = new Patch(id, full_path);
        if (newPatch) {
          newPatch.paths = patch.paths.concat(node_module_paths(full_path));
          newPatch.npm = true;
          newPatch.alias = req;
          result.push(newPatch.id);
          newPatch.deps || (newPatch.deps = depsFromPatch(newPatch, options));
          return next();
        }
      });
    })();
  };

  module.exports = Stitch;

}).call(this);
