// Generated by CoffeeScript 1.7.0
(function() {
  var Log, Patch, Stitch, Utils, cache, compilers, createPatchFromPath, depsFromPatch, detective, findAllDependencies, fs, lookup_path, modulerize, natives, node_module_paths, resolve, walk, _module, _path;

  _path = require('path');

  fs = require('fs');

  compilers = require('./compilers');

  Utils = require('./utils');

  Log = require('./log');

  detective = require('detective');

  _module = require('module');

  natives = process.binding('natives');

  cache = {
    file: {},
    byId: {}
  };

  walk = function(type, path, parent, result) {
    var child, patch, stat, _i, _len, _ref;
    if (parent == null) {
      parent = path;
    }
    if (result == null) {
      result = [];
    }
    if (!fs.existsSync(path)) {
      return;
    }
    _ref = fs.readdirSync(path);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child = _path.join(path, child);
      stat = fs.statSync(child);
      if (stat.isDirectory()) {
        walk(type, child, parent, result);
      } else {
        patch = createPatchFromPath({
          type: type,
          fullPath: child,
          parent: parent
        });
        if (patch) {
          result.push(patch);
        }
      }
    }
    return result;
  };

  createPatchFromPath = function(options) {
    var fullPath, id, parent, patch, type;
    type = options.type;
    fullPath = options.fullPath;
    parent = options.parent;
    if (!cache.file[fullPath]) {
      id = modulerize(fullPath, parent, _path.extname(fullPath));
      patch = new Patch(id, fullPath, type);
    }
    return cache.file[fullPath];
  };

  modulerize = function(filename, parent, ext) {
    var baseName, dirName, id, modName, parts;
    if (filename[0] === ".") {
      parts = parent.split(_path.sep);
      parent = parent.replace(/(node_modules(\/|\\)[^/\\]+)\/.+/, "$1");
      filename = _path.resolve(parent, filename);
      id = filename.replace(/.+node_modules(\/|\\)/, "");
      if (filename.indexOf("validate") > 0) {
        console.log("+", filename, id);
      }
    } else {
      id = filename.replace(_path.join(parent, _path.sep), '');
    }
    baseName = ext ? _path.basename(id, ext) : _path.basename(id);
    dirName = _path.dirname(id);
    modName = _path.join(_path.dirname(id), baseName);
    return modName.replace(/\\/g, '/');
  };

  findAllDependencies = function(patch, patches) {
    var deps, next;
    deps = patch.depends();
    return (next = function() {
      var dep, id;
      id = deps.shift();
      if (!id) {
        return;
      }
      dep = cache.byId[id];
      if (patches.indexOf(dep === -1)) {
        patches.push(dep);
        findAllDependencies(dep, patches);
      }
      return next();
    })();
  };

  Stitch = (function() {
    Stitch.cache = cache;

    Stitch.ignoreMissingDependencies = true;

    Stitch.reportMissingDependencies = true;

    Stitch.resolvers = {
      js: function(patches, options) {
        var identifier, patch, _i, _len;
        if (options == null) {
          options = {};
        }
        if (options.npm) {
          for (_i = 0, _len = patches.length; _i < _len; _i++) {
            patch = patches[_i];
            findAllDependencies(patch, patches);
          }
        }
        if (options.bundle) {
          if (options.commonjs) {
            identifier = typeof options.commonjs === 'boolean' ? 'require' : options.commonjs;
            return Stitch.bundle(patches, identifier);
          } else {
            return Stitch.join(patches, options.separator);
          }
        } else {
          return patches;
        }
      },
      css: function(patches, options) {
        if (options == null) {
          options = {};
        }
        if (options.bundle) {
          return Stitch.join(patches, options.separator);
        } else {
          return patches;
        }
      }
    };

    Stitch.bundle = function(patches, identifier) {
      var context;
      context = {
        identifier: identifier,
        modules: patches
      };
      return Utils.tmpl("stitch", context);
    };

    Stitch.join = function(patches, separator) {
      var patch;
      if (separator == null) {
        separator = "\n";
      }
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = patches.length; _i < _len; _i++) {
          patch = patches[_i];
          _results.push(patch.compile());
        }
        return _results;
      })()).join(separator);
    };

    Stitch["delete"] = function(filename) {
      var patch;
      patch = cache.file(_path.resolve(filename));
      if (patch) {
        delete cache.file[patch.filename];
        return delete cache.byId[patch.id];
      }
    };

    function Stitch(paths, type) {
      var path;
      this.paths = paths != null ? paths : [];
      this.type = type != null ? type : 'js';
      this.paths = (function() {
        var _i, _len, _ref, _results;
        _ref = this.paths;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          _results.push(_path.resolve(path));
        }
        return _results;
      }).call(this);
      if (!Stitch.resolvers[this.type]) {
        throw new Error("Invalid type supplied to Stitch contructor");
      }
    }

    Stitch.prototype.resolve = function(options) {
      var patches, path;
      if (options == null) {
        options = {};
      }
      patches = Utils.flatten((function() {
        var _i, _len, _ref, _results;
        _ref = this.paths;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          _results.push(walk(this.type, path));
        }
        return _results;
      }).call(this));
      return Stitch.resolvers[this.type](patches, options);
    };

    return Stitch;

  })();

  Patch = (function() {
    function Patch(id, filename, type) {
      this.id = id;
      this.filename = filename;
      this.type = type != null ? type : "js";
      this.ext = _path.extname(this.filename).slice(1);
      this.appPath = this.filename.replace(process.cwd(), '');
      if (this.valid() && this.compile()) {
        cache.file[this.filename] = this;
        if (this.id) {
          cache.byId[this.id] = this;
        }
      }
    }

    Patch.prototype.compile = function() {
      try {
        return this.source || (this.source = compilers[this.ext](this.filename));
      } catch (_error) {
        throw new Error(this.missing);
      }
    };

    Patch.prototype.depends = function() {
      return this.deps || (this.deps = depsFromPatch(this));
    };

    Patch.prototype.valid = function() {
      return !!compilers[this.ext];
    };

    return Patch;

  })();

  lookup_path = function(name, parent) {
    var paths, resolved_module;
    resolved_module = _module.Module._resolveLookupPaths(name, parent);
    paths = resolved_module[1];
    return _module.Module._findPath(name, paths);
  };

  node_module_paths = function(filename) {
    return _module.Module._nodeModulePaths(_path.dirname(filename));
  };

  resolve = function(id, parent, cb) {
    parent.paths || (parent.paths = node_module_paths(parent.filename));
    return cb(lookup_path(id, parent));
  };

  depsFromPatch = function(patch) {
    var next, requires, result;
    result = [];
    requires = detective(patch.source);
    requires = requires.filter(function(elem, idx) {
      return requires.indexOf(elem) === idx;
    });
    return (next = function() {
      var id, req;
      req = requires.shift();
      if (!req) {
        return result;
      }
      id = modulerize(req, patch.filename);
      return resolve(req, patch, function(full_path) {
        var dep, newPatch;
        if (!full_path) {
          if (cache.byId[id]) {
            result.push(id);
            return next();
          }
          if (natives[id]) {
            throw new Error('Cannot require native module: \'' + req + '\' from ' + patch.filename);
          }
          if (Stitch.ignoreMissingDependencies === false) {
            throw new Error("" + patch.appPath + " contains missing module " + id);
          }
          if (Stitch.reportMissingDependencies) {
            Log.error("" + patch.appPath + " contains missing module <green>" + id + "</green>");
          }
          return next();
        }
        dep = cache.file[full_path];
        if (dep) {
          result.push(dep.id);
          return next();
        }
        newPatch = new Patch(id, full_path);
        if (newPatch) {
          newPatch.paths = patch.paths.concat(node_module_paths(full_path));
          newPatch.npm = true;
          newPatch.alias = req;
          result.push(newPatch.id);
          newPatch.depends();
          return next();
        }
      });
    })();
  };

  module.exports = Stitch;

}).call(this);
