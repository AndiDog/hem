// Generated by CoffeeScript 1.7.0
(function() {
  var Log, Source, Stitch, Utils, cache, compilers, depsFromSource, detective, findAllDependencies, fs, glob, lookup_path, natives, node_module_paths, resolve, _module, _path,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _path = require('path');

  fs = require('fs');

  compilers = require('./compilers');

  Utils = require('./utils');

  Log = require('./log');

  glob = require('globule');

  detective = require('detective');

  _module = require('module');

  natives = process.binding('natives');

  cache = {
    file: {},
    byId: {}
  };

  Stitch = (function() {
    Stitch.instances = [];

    Stitch.ignoreMissingDependencies = true;

    Stitch.reportMissingDependencies = false;

    Stitch.resolvers = {
      js: function(sources, options) {
        var identifier, source, _i, _len;
        if (options == null) {
          options = {};
        }
        options.ignoreMissingDependencies || (options.ignoreMissingDependencies = Stitch.ignoreMissingDependencies);
        options.reportMissingDependencies || (options.reportMissingDependencies = Stitch.reportMissingDependencies);
        if (options.reportMissingDependencies || !options.ignoreMissingDependencies || options.npm) {
          for (_i = 0, _len = sources.length; _i < _len; _i++) {
            source = sources[_i];
            findAllDependencies(source, sources, options);
          }
        }
        if (options.bundle) {
          if (options.commonjs) {
            identifier = typeof options.commonjs === 'boolean' ? 'require' : options.commonjs;
            return {
              source: Stitch.bundle(sources, identifier)
            };
          } else {
            return {
              source: Stitch.join(sources, options.separator)
            };
          }
        } else {
          return sources;
        }
      },
      css: function(sources, options) {
        var source;
        if (options == null) {
          options = {};
        }
        if (!options.target) {
          sources;
        }
        if (_path.extname(filename)) {
          return source = Stitch.join(sources, options.separator);
        } else {

        }
      }
    };

    Stitch.bundle = function(sources, identifier) {
      var context;
      context = {
        identifier: identifier,
        modules: sources
      };
      return Utils.tmpl("stitch", context);
    };

    Stitch.join = function(sources, separator) {
      var source;
      if (separator == null) {
        separator = "\n";
      }
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = sources.length; _i < _len; _i++) {
          source = sources[_i];
          _results.push(source.source);
        }
        return _results;
      })()).join(separator);
    };

    Stitch.remove = function(filename) {
      var source, stitch, _i, _len, _ref, _results;
      source = cache.file[_path.resolve(filename)];
      if (!source) {
        return;
      }
      delete cache.file[source.filename];
      delete cache.byId[source.id];
      _ref = this.instances;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stitch = _ref[_i];
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = stitch.walk;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            source = _ref1[_j];
            if (stitch.cache) {
              if (source.filename === filename) {
                _results1.push(delete stitch.cache);
              } else {
                _results1.push(void 0);
              }
            }
          }
          return _results1;
        })());
      }
      return _results;
    };

    Stitch.registerInstance = function(stitch) {
      return this.instances.push(stitch);
    };

    function Stitch(paths, type) {
      this.paths = paths != null ? paths : [];
      this.type = type != null ? type : 'js';
      if (!Stitch.resolvers[this.type]) {
        throw new Error("Invalid type value supplied to Stitch contructor");
      }
      Stitch.registerInstance(this);
    }

    Stitch.prototype.resolve = function(options) {
      var file, path, source, walk, _i, _j, _len, _len1, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      if (!this.cache) {
        walk = [];
        _ref = this.paths;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          _ref1 = path.walk();
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            file = _ref1[_j];
            if (fs.statSync(file).isDirectory()) {
              continue;
            }
            source = Source.createFromPath(file, path, this.type);
            if (source) {
              walk.push(source);
            }
          }
        }
        console.log(walk);
        this.cache = Stitch.resolvers[this.type](walk, options);
        console.log(this.cache);
      }
      return this.cache;
    };

    return Stitch;

  })();

  Source = (function() {
    Source.modulerize = function(filename, parent) {
      var baseName, dirName, ext, id, modName, parts;
      ext = _path.extname(filename);
      if (filename[0] === ".") {
        parts = parent.split(_path.sep);
        parent = parent.replace(/(node_modules(\/|\\)[^/\\]+)\/.+/, "$1");
        filename = _path.resolve(parent, filename);
        id = filename.replace(/.+node_modules(\/|\\)/, "");
      } else {
        id = filename.replace(_path.join(parent, _path.sep), '');
      }
      baseName = ext ? _path.basename(id, ext) : _path.basename(id);
      dirName = _path.dirname(id);
      modName = _path.join(_path.dirname(id), baseName);
      return modName.replace(/\\/g, '/');
    };

    Source.isValid = function(filename) {
      var ext;
      ext = _path.extname(filename).slice(1).toLowerCase();
      return !!compilers[ext];
    };

    Source.createFromPath = function(filename, path, type) {
      var src;
      if (!cache.file[filename] && Source.isValid(filename)) {
        src = new Source(filename, path, type);
      }
      return cache.file[filename];
    };

    function Source(filename, path, type) {
      this.filename = filename;
      this.path = path;
      this.type = type != null ? type : "js";
      this.ext = _path.extname(this.filename).slice(1).toLowerCase();
      if (this.type === "js") {
        this.id = Source.modulerize(filename, this.path.srcBase);
      }
      this.source = compilers[this.ext](this.filename);
      cache.file[this.filename] = this;
      if (this.id) {
        cache.byId[this.id] = this;
      }
    }

    return Source;

  })();

  findAllDependencies = function(source, sources, options) {
    var deps, next;
    deps = source.deps || (source.deps = depsFromSource(source, options));
    return (next = function() {
      var dep, id;
      id = deps.shift();
      if (!id) {
        return;
      }
      dep = cache.byId[id];
      if (__indexOf.call(sources, dep) < 0) {
        sources.push(dep);
        findAllDependencies(dep, sources, options);
      }
      return next();
    })();
  };

  lookup_path = function(name, parent) {
    var paths, resolved_module;
    resolved_module = _module.Module._resolveLookupPaths(name, parent);
    paths = resolved_module[1];
    return _module.Module._findPath(name, paths);
  };

  node_module_paths = function(filename) {
    return _module.Module._nodeModulePaths(_path.dirname(filename));
  };

  resolve = function(id, parent, cb) {
    parent.paths || (parent.paths = node_module_paths(parent.filename));
    return cb(lookup_path(id, parent));
  };

  depsFromSource = function(source, options) {
    var next, requires, result;
    result = [];
    requires = detective(source.source);
    requires = requires.filter(function(elem, idx) {
      return requires.indexOf(elem) === idx;
    });
    return (next = function() {
      var id, req;
      req = requires.shift();
      if (!req) {
        return result;
      }
      id = modulerize(req, source.filename);
      return resolve(req, source, function(full_path) {
        var dep, newSource;
        if (!full_path) {
          if (cache.byId[id]) {
            result.push(id);
            return next();
          }
          if (natives[id] && options.npm) {
            throw new Error('Cannot require native module: \'' + req + '\' from ' + source.filename);
          }
          if (options.ignoreMissingDependencies === false) {
            throw new Error("" + source.filename + " contains missing module " + id);
          }
          if (options.reportMissingDependencies) {
            Log.info("<yellow>Warning:</yellow> " + source.filename + " contains missing module <green>" + id + "</green>");
          }
          return next();
        }
        if (!options.npm) {
          return next();
        }
        dep = cache.file[full_path];
        if (dep) {
          result.push(dep.id);
          return next();
        }
        newSource = new Source(id, full_path);
        if (newSource) {
          newSource.paths = source.paths.concat(node_module_paths(full_path));
          newSource.npm = true;
          newSource.alias = req;
          result.push(newSource.id);
          newSource.deps || (newSource.deps = depsFromSource(newSource, options));
          return next();
        }
      });
    })();
  };

  module.exports = Stitch;

}).call(this);
