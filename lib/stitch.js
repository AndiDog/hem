// Generated by CoffeeScript 1.7.0
(function() {
  var Module, Stitch, Utils, compilers, createModule, fs, modulerize, resolvers, walk, _modulesByFile, _modulesById, _path;

  _path = require('path');

  fs = require('fs');

  compilers = require('./compilers');

  Utils = require('./utils');

  _modulesByFile = {};

  _modulesById = {};

  walk = function(type, path, parent, result) {
    var child, module, stat, _i, _len, _ref;
    if (parent == null) {
      parent = path;
    }
    if (result == null) {
      result = [];
    }
    if (!fs.existsSync(path)) {
      return;
    }
    _ref = fs.readdirSync(path);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child = _path.join(path, child);
      stat = fs.statSync(child);
      if (stat.isDirectory()) {
        walk(type, child, parent, result);
      } else {
        module = createModule(type, child, parent);
        result.push(module);
      }
    }
    return result;
  };

  createModule = function(type, child, parent) {
    var module;
    if (!_modulesByFile[child]) {
      module = new Module(child, parent, type);
      if (module.valid() && module.compile()) {
        _modulesByFile[child] = module;
        if (module.id) {
          _modulesById[module.id] = module;
        }
      }
    }
    return _modulesByFile[child];
  };

  modulerize = function(id, filename) {
    var baseName, dirName, ext, modName;
    if (filename == null) {
      filename = id;
    }
    ext = _path.extname(filename);
    dirName = _path.dirname(id);
    baseName = _path.basename(id, ext);
    if (dirName === baseName) {
      modName = baseName;
    } else {
      modName = _path.join(_path.dirname(id), _path.basename(id, ext));
    }
    return modName.replace(/\\/g, '/');
  };

  resolvers = {
    js: function(modules, options) {
      var identifier, mod, _i, _len;
      if (options == null) {
        options = {};
      }
      if (options.npm) {
        for (_i = 0, _len = modules.length; _i < _len; _i++) {
          mod = modules[_i];
          mod.depends();
        }
      }
      if (options.bundle) {
        if (options.commonjs) {
          identifier = typeof options.commonjs === 'boolean' ? 'require' : options.commonjs;
          return Stitch.bundle(modules, identifier);
        } else {
          return Stitch.join(modules, options.separator);
        }
      } else {
        return modules;
      }
    },
    css: function(modules, options) {
      if (options == null) {
        options = {};
      }
      if (options.bundle) {
        return Stitch.join(modules, options.separator);
      } else {
        return modules;
      }
    }
  };

  Stitch = (function() {
    Stitch.bundle = function(modules, identifier) {
      var context;
      context = {
        identifier: identifier,
        modules: modules
      };
      return Utils.tmpl("stitch", context);
    };

    Stitch.join = function(modules, separator) {
      var mod;
      if (separator == null) {
        separator = "\n";
      }
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = modules.length; _i < _len; _i++) {
          mod = modules[_i];
          _results.push(mod.compile());
        }
        return _results;
      })()).join(separator);
    };

    Stitch["delete"] = function(filename) {
      var mod;
      mod = _modulesByFile(_path.resolve(filename));
      if (mod) {
        delete modulesByFile[mod.filename];
        return delete modulesById[mod.id];
      }
    };

    function Stitch(paths, type) {
      var path;
      this.paths = paths != null ? paths : [];
      this.type = type != null ? type : 'js';
      this.paths = (function() {
        var _i, _len, _ref, _results;
        _ref = this.paths;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          _results.push(_path.resolve(path));
        }
        return _results;
      }).call(this);
      if (!resolvers[this.type]) {
        throw new Error("Invalid type supplied to Stitch contructor");
      }
    }

    Stitch.prototype.resolve = function(options) {
      var modules, path;
      if (options == null) {
        options = {};
      }
      modules = Utils.flatten((function() {
        var _i, _len, _ref, _results;
        _ref = this.paths;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          _results.push(walk(this.type, path));
        }
        return _results;
      }).call(this));
      return resolvers[this.type](modules, options);
    };

    return Stitch;

  })();

  Module = (function() {
    function Module(filename, parent, type) {
      this.filename = filename;
      this.parent = parent;
      this.type = type;
      this.ext = _path.extname(this.filename).slice(1);
      if (this.type === "js") {
        this.id = modulerize(this.filename.replace(_path.join(this.parent, _path.sep), ''));
      }
    }

    Module.prototype.compile = function() {
      return this.source || (this.source = compilers[this.ext](this.filename));
    };

    Module.prototype.depends = function() {
      return require('./dependency')(this, (function(_this) {
        return function(err, res) {
          if (res.length > 0) {
            return console.log(_this.id, err, res);
          }
        };
      })(this));
    };

    Module.prototype.valid = function() {
      return !!compilers[this.ext];
    };

    return Module;

  })();

  module.exports = Stitch;

}).call(this);
