// Generated by CoffeeScript 1.7.0
(function() {
  var Patch, Stitch, Utils, compilers, createPatch, fs, modulerize, resolvers, walk, _patchesByFile, _patchesById, _path;

  _path = require('path');

  fs = require('fs');

  compilers = require('./compilers');

  Utils = require('./utils');

  _patchesByFile = {};

  _patchesById = {};

  walk = function(type, path, parent, result) {
    var child, patch, stat, _i, _len, _ref;
    if (parent == null) {
      parent = path;
    }
    if (result == null) {
      result = [];
    }
    if (!fs.existsSync(path)) {
      return;
    }
    _ref = fs.readdirSync(path);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child = _path.join(path, child);
      stat = fs.statSync(child);
      if (stat.isDirectory()) {
        walk(type, child, parent, result);
      } else {
        patch = createPatch(type, child, parent);
        result.push(patch);
      }
    }
    return result;
  };

  createPatch = function(type, child, parent) {
    var patch;
    if (!_patchesByFile[child]) {
      patch = new Patch(child, parent, type);
      if (patch.valid() && patch.compile()) {
        _patchesByFile[child] = patch;
        if (patch.id) {
          _patchesById[patch.id] = patch;
        }
      }
    }
    return _patchesByFile[child];
  };

  modulerize = function(filename, parent) {
    var baseName, dirName, ext, id, modName;
    id = filename.replace(_path.join(parent, _path.sep), '');
    ext = _path.extname(filename);
    dirName = _path.dirname(id);
    baseName = _path.basename(id, ext);
    if (dirName === baseName) {
      modName = baseName;
    } else {
      modName = _path.join(_path.dirname(id), _path.basename(id, ext));
    }
    return modName.replace(/\\/g, '/');
  };

  resolvers = {
    js: function(patches, options) {
      var identifier, patch, _i, _len;
      if (options == null) {
        options = {};
      }
      if (options.npm) {
        for (_i = 0, _len = patches.length; _i < _len; _i++) {
          patch = patches[_i];
          patch.depends();
        }
      }
      if (options.bundle) {
        if (options.commonjs) {
          identifier = typeof options.commonjs === 'boolean' ? 'require' : options.commonjs;
          return Stitch.bundle(patches, identifier);
        } else {
          return Stitch.join(patches, options.separator);
        }
      } else {
        return patches;
      }
    },
    css: function(patches, options) {
      if (options == null) {
        options = {};
      }
      if (options.bundle) {
        return Stitch.join(patches, options.separator);
      } else {
        return patches;
      }
    }
  };

  Stitch = (function() {
    Stitch.bundle = function(patches, identifier) {
      var context;
      context = {
        identifier: identifier,
        modules: patches
      };
      return Utils.tmpl("stitch", context);
    };

    Stitch.join = function(patches, separator) {
      var patch;
      if (separator == null) {
        separator = "\n";
      }
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = patches.length; _i < _len; _i++) {
          patch = patches[_i];
          _results.push(patch.compile());
        }
        return _results;
      })()).join(separator);
    };

    Stitch["delete"] = function(filename) {
      var patch;
      patch = _patchesByFile(_path.resolve(filename));
      if (patch) {
        delete _patchesByFile[patch.filename];
        return delete _patchesById[patch.id];
      }
    };

    function Stitch(paths, type) {
      var path;
      this.paths = paths != null ? paths : [];
      this.type = type != null ? type : 'js';
      this.paths = (function() {
        var _i, _len, _ref, _results;
        _ref = this.paths;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          _results.push(_path.resolve(path));
        }
        return _results;
      }).call(this);
      if (!resolvers[this.type]) {
        throw new Error("Invalid type supplied to Stitch contructor");
      }
    }

    Stitch.prototype.resolve = function(options) {
      var patches, path;
      if (options == null) {
        options = {};
      }
      patches = Utils.flatten((function() {
        var _i, _len, _ref, _results;
        _ref = this.paths;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          _results.push(walk(this.type, path));
        }
        return _results;
      }).call(this));
      return resolvers[this.type](patches, options);
    };

    return Stitch;

  })();

  Patch = (function() {
    function Patch(filename, parent, type) {
      this.filename = filename;
      this.parent = parent;
      this.type = type;
      this.ext = _path.extname(this.filename).slice(1);
      if (this.type === "js") {
        this.id = modulerize(this.filename, this.parent);
      }
    }

    Patch.prototype.compile = function() {
      return this.source || (this.source = compilers[this.ext](this.filename));
    };

    Patch.prototype.depends = function() {
      return require('./dependency')(this, (function(_this) {
        return function(err, res) {
          if (res.length > 200) {
            return console.log(_this.id, err, res);
          }
        };
      })(this));
    };

    Patch.prototype.valid = function() {
      return !!compilers[this.ext];
    };

    return Patch;

  })();

  module.exports = Stitch;

}).call(this);
