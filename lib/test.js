// Generated by CoffeeScript 1.7.0
(function() {
  var async, events, fs, log, path, phantom, run, runBrowser, runPhantom, utils;

  fs = require('fs');

  path = require('path');

  async = require('async');

  log = require('./log');

  utils = require('./utils');

  events = require('./events');

  phantom = require('./phantom');

  run = function(apps, options) {
    var runTests;
    switch (options.runner) {
      case "phantom":
        runTests = phantom.run ? runPhantom : runBrowser;
        break;
      case "browser":
        runTests = runBrowser;
        break;
      default:
        log.errorAndExit("Invalid or unset test runner value: <yellow>" + options.runner + "</yellow>");
    }
    return runTests(apps, options);
  };

  runBrowser = function(apps, options, done) {
    var app, open, q, task, taskObject, tasks, testFile, testName, _i, _len, _results;
    open = require("open");
    tasks = {};
    for (_i = 0, _len = apps.length; _i < _len; _i++) {
      app = apps[_i];
      testName = app.name;
      testFile = app.getTestPackage().getTestIndexFile();
      tasks[testName] = (function(testFile) {
        return function(done) {
          open(testFile);
          return done();
        };
      })(testFile);
    }
    if (options.singleRun) {
      return async.series(tasks);
    } else {
      q = async.queue((function(task, callback) {
        return task(callback);
      }), 1);
      _results = [];
      for (task in tasks) {
        taskObject = tasks[task];
        _results.push(events.on("watch", function(app, pkg, file) {
          return q.push(tasks[app.name]);
        }));
      }
      return _results;
    }
  };

  runPhantom = function(apps, options, done) {
    var app, q, task, taskObject, tasks, testFile, testName, testPort, _i, _len;
    options.output || (options.output = "passOrFail");
    tasks = {};
    for (_i = 0, _len = apps.length; _i < _len; _i++) {
      app = apps[_i];
      testName = app.name;
      testFile = app.getTestPackage().getTestIndexFile();
      testPort = 12300 + Object.keys(tasks).length;
      tasks[testName] = (function(testName, testFile, testPort) {
        return function(done) {
          log("Testing application targets: <green>" + testName + "</green>");
          return phantom.run(testFile, options, function(results) {
            if (results.error) {
              log.error(results.error);
            }
            return done(null, results);
          }, testPort);
        };
      })(testName, testFile, testPort);
    }
    if (options.singleRun) {
      async.series(tasks, function(err, results) {
        var exitCode, name, result;
        exitCode = 0;
        for (name in results) {
          result = results[name];
          exitCode += result.failed && result.failed || 0;
          exitCode += result.error && 1 || 0;
        }
        return process.exit(exitCode);
      });
    } else {
      q = async.queue((function(task, callback) {
        return task(callback);
      }), 1);
      for (task in tasks) {
        taskObject = tasks[task];
        events.on("watch", function(app, pkg, file) {
          return q.push(tasks[app.name]);
        });
      }
    }
    return {
      constructor: function(task) {
        var _ref;
        this.testHome = path.dirname(this.target);
        this.framework = task.test;
        if ((_ref = this.framework) !== 'jasmine' && _ref !== 'mocha') {
          log.errorAndExit("Test frameworks value is not valid: " + this.framework);
        }
        return this.after += "// HEM: load in specs from test js file\nvar onlyMatchingModules = \"" + (_argv.grep || "") + "\";\nfor (var key in " + this.commonjs + ".modules) {\n  if (onlyMatchingModules && key.indexOf(onlyMatchingModules) == -1) {\n    continue;\n  }\n  " + this.commonjs + "(key); \n}";
      },
      createTestFiles: function() {
        var file, filepath, files, frameworkPath, indexFile, template, _j, _len1, _ref, _ref1, _results;
        indexFile = this.getTestIndexFile();
        files = [];
        files.push.apply(files, this.getFrameworkFiles());
        files.push.apply(files, this.getAllTestTargets());
        template = utils.tmpl("testing/index", {
          commonjs: this.commonjs,
          files: files,
          before: this.before
        });
        fs.outputFileSync(indexFile, template);
        frameworkPath = path.resolve(__dirname, "../assets/testing/" + this.framework);
        _ref = fs.readdirSync(frameworkPath);
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          file = _ref[_j];
          if ((_ref1 = path.extname(file)) === ".js" || _ref1 === ".css") {
            filepath = path.resolve(this.testHome, "" + this.framework + "/" + file);
            _results.push(utils.copyFile(path.resolve(frameworkPath, file), filepath));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      getAllTestTargets: function(relative) {
        var dep, depapp, homeRoute, pkg, pth, relativeFn, targets, url, _j, _k, _l, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3;
        if (relative == null) {
          relative = true;
        }
        targets = [];
        homeRoute = path.dirname(this.route);
        relativeFn = function(home, target) {
          if (relative) {
            return path.relative(home, target);
          } else {
            return target;
          }
        };
        _ref = this.depends;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          dep = _ref[_j];
          _ref1 = _hem.allApps;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            depapp = _ref1[_k];
            if (depapp.name === dep) {
              _ref2 = depapp.packages;
              for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
                pkg = _ref2[_l];
                if (pkg.constructor.name !== "JsPackage") {
                  continue;
                }
                url = relativeFn(homeRoute, pkg.route);
                pth = relativeFn(this.testHome, pkg.target);
                targets.push({
                  url: url,
                  path: pth
                });
              }
            }
          }
        }
        _ref3 = this.app.packages;
        for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
          pkg = _ref3[_m];
          if (pkg.constructor.name !== "JsPackage") {
            continue;
          }
          url = relativeFn(homeRoute, pkg.route);
          pth = relativeFn(this.testHome, pkg.target);
          targets.push({
            url: url,
            path: pth
          });
        }
        url = relativeFn(homeRoute, pkg.route);
        pth = relativeFn(this.testHome, pkg.target);
        targets.push({
          url: url,
          path: pth
        });
        return targets;
      },
      getFrameworkFiles: function() {
        var file, frameworkPath, targets, url, _j, _len1, _ref, _ref1;
        targets = [];
        frameworkPath = path.resolve(__dirname, "../assets/testing/" + this.framework);
        _ref = fs.readdirSync(frameworkPath);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          file = _ref[_j];
          if ((_ref1 = path.extname(file)) === ".js" || _ref1 === ".css") {
            url = "" + this.framework + "/" + file;
            targets.push({
              url: url,
              path: url
            });
          }
        }
        return targets;
      },
      getTestIndexFile: function() {
        return path.resolve(this.testHome, 'index.html');
      }
    };
  };

  module.exports.run = run;

  module.exports.phantom = phantom;

}).call(this);
