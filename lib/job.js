// Generated by CoffeeScript 1.7.0
(function() {
  var Events, Job, Log, Stitch, TaskWrapper, Utils, fs, gaze, path, uglifycss, uglifyjs;

  fs = require('fs-extra');

  gaze = require('gaze');

  path = require('path');

  Utils = require('./utils');

  Events = require('./events');

  Log = require('./log');

  Stitch = require('./stitch');

  uglifyjs = require('uglify-js');

  uglifycss = require('uglifycss');

  Job = (function() {
    function Job(app, name, config) {
      var taskHelper, tconfig, _i, _len;
      this.app = app;
      this.name = name;
      this.sname = name.charAt(0).toUpperCase() + name.slice(1);
      this.tasks = [];
      taskHelper = (function(_this) {
        return function(taskConfig) {
          var task;
          task = _this.createTask(taskConfig);
          task.id = _this.tasks.length;
          return _this.tasks.push(task);
        };
      })(this);
      if (Array.isArray(config)) {
        for (_i = 0, _len = config.length; _i < _len; _i++) {
          tconfig = config[_i];
          taskHelper(tconfig);
        }
      } else if (config) {
        taskHelper(config);
      }
    }

    Job.prototype.createTask = function(config) {
      if (!config.task) {
        Log.errorAndExit("Missing task value for job " + this.name);
      }
      if (Job.tasks[config.task]) {
        return new TaskWrapper(this, config);
      } else {
        return Log.errorAndExit("Cannot find task <blue>" + config.task + "</blue> for job <yellow>" + this.name + "</yellow>");
      }
    };

    Job.prototype.run = function(id, params) {
      var callback, ex, handleError, results, task, watch, _i, _len, _ref;
      if (params == null) {
        params = {};
      }
      watch = this.app.argv.watch && '<b>(and watch)</b> ' || '';
      Log("" + this.sname + " " + watch + "application: <green>" + this.app.name + "</green>");
      results = [];
      handleError = (function(_this) {
        return function(task, ex) {
          Log.error("During execution of <yellow>" + task.name + "</yellow> task in (" + _this.app.name + " > " + _this.name + ")");
          if (ex.name === "CompileError") {
            Log("       Mess: " + ex.message);
            Log("       Path: " + ex.path);
          } else {
            Log("  " + ex.stack);
          }
          if (task.result) {
            results.push(task.result);
          }
          if (!_this.app.argv.watch) {
            return process.exit(1);
          }
        };
      })(this);
      _ref = this.tasks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        task = _ref[_i];
        if (!(!id || task.id === id)) {
          continue;
        }
        callback = (function(task) {
          return function(err, result) {
            if (err) {
              return handleError(task, err);
            } else {
              if (result) {
                return results.push(result);
              }
            }
          };
        })(task);
        try {
          task.run(callback, params);
        } catch (_error) {
          ex = _error;
          callback(ex);
        }
      }
      this.write(results);
      if (id) {
        if (results.length === 1) {
          return results[0];
        } else {
          return results;
        }
      } else {
        return results;
      }
    };

    Job.prototype.write = function(results) {
      var item, result, writeFile, _i, _len, _results;
      writeFile = (function(_this) {
        return function(item) {
          var dirname, ext;
          if (!(item.target && item.source)) {
            return;
          }
          ext = path.extname(item.target).slice(1).toLowerCase();
          if (_this.app.argv.compress && _this.minify[ext]) {
            item.source = _this.minify[ext](item.source);
          }
          if (_this.app.argv.command === "server") {
            return;
          }
          dirname = path.dirname(item.target);
          if (!fs.existsSync(dirname)) {
            fs.mkdirsSync(dirname);
          }
          return fs.writeFileSync(target, item.source);
        };
      })(this);
      _results = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        result = results[_i];
        if (Array.isArray(result)) {
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = result.length; _j < _len1; _j++) {
              item = result[_j];
              if (typeof item === "object") {
                _results1.push(writeFile(item));
              }
            }
            return _results1;
          })());
        } else if (typeof result === "object") {
          _results.push(writeFile(result));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Job.prototype.minify = {
      js: function(source) {
        return uglifyjs.minify(source, {
          fromString: true
        }).code;
      },
      css: function(source) {
        return uglifycss.processString(source);
      }
    };

    Job.prototype.watch = function() {
      var callback, task, watched, _i, _len, _ref, _results;
      _ref = this.tasks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        task = _ref[_i];
        watched = task.watch || task.src;
        if (!watched) {
          continue;
        }
        callback = (function(task) {
          return function(event, filepath) {
            task.job.run(task.id, {
              watch: filepath
            });
            return Events.emit("watch", task, event, filepath);
          };
        })(task);
        _results.push(gaze(task.watch, function(err, watcher) {
          if (err) {
            Log.errorAndExit(err);
          }
          return watcher.on('all', function(event, filepath) {
            return callback(event, filepath);
          });
        }));
      }
      return _results;
    };

    Job.prototype.init = function(task) {
      if (task.target) {
        task.target = this.app.applyRoot(task.target);
        task.target = Utils.tmplStr(task.target, task);
      }
      if (task.src) {
        task.src = this.app.createPaths(task.src);
      }
      if (task.watch) {
        task.watch = this.app.createPaths(task.watch);
      }
      return this.initRoutes(task);
    };

    Job.prototype.initRoutes = function(task) {
      var regexp, sroute, targetUrl, _i, _len, _ref, _results;
      if (this.route) {
        if (!Utils.startsWith(this.route, "/")) {
          return this.route = this.app.applyRoute(this.route);
        }
      } else {
        _ref = this.app["static"];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          sroute = _ref[_i];
          if (!this.route) {
            if (Utils.startsWith(this.target, sroute.path)) {
              regexp = new RegExp("^" + (sroute.path.replace(/\\/g, "\\\\")) + "(\\\\|\/)?");
              targetUrl = this.target.replace(regexp, "");
              _results.push(this.route = Utils.cleanRoute(sroute.url, targetUrl));
            } else {
              _results.push(void 0);
            }
          }
        }
        return _results;
      }
    };

    return Job;

  })();

  TaskWrapper = (function() {
    function TaskWrapper(job, config) {
      var key, value, _base;
      this.job = job;
      this.name = config.task;
      this.app = job.app;
      for (key in config) {
        value = config[key];
        if (key !== 'job' && key !== 'id' && key !== 'name' && key !== 'task' && key !== 'run' && key !== 'app') {
          this[key] = value;
        }
      }
      this.task = typeof (_base = Job.tasks[config.task]).call === "function" ? _base.call(this) : void 0;
      if (typeof this.task !== 'function') {
        Log.errorAndExit("The job <yellow>" + this.job.name + "</yellow> task <blue>" + this.name + "</blue> is invalid.");
      }
      this.job.init(this);
      if (this.app.argv.command === "server" && !this.route) {
        Log.errorAndExit("Unable to determine server route for <yellow>" + this.target + "</yellow>");
      }
    }

    TaskWrapper.prototype.run = function(callback, params) {
      if (typeof this.task === "function") {
        return this.task.call(this, callback, params);
      } else {
        return Log.errorAndExit("In job '" + this.job.name + " the task '" + this.name + "' needs to be a function.");
      }
    };

    return TaskWrapper;

  })();

  Job.tasks = Utils.requireDirectory("" + __dirname + "/tasks");

  module.exports = Job;

}).call(this);
